"""
DynPRE Ground Truth Loader

Loads ground truth data generated by DynPRE for fair comparison.
"""

import csv
import logging
from typing import List, Tuple, Dict
from pathlib import Path


class DynPREGroundTruthLoader:
    """
    Loads ground truth from DynPRE output files.
    """

    def __init__(self, dynpre_output_dir: str = './../../DynPRE/examples'):
        """
        Args:
            dynpre_output_dir: Directory containing DynPRE output files
        """
        self.output_dir = Path(dynpre_output_dir)
        logging.info(f"DynPREGroundTruthLoader initialized. Output directory: {self.output_dir}")

    def load_ground_truth(self, protocol: str) -> Tuple[List[bytes], List[List[int]]]:
        """
        Load ground truth from DynPRE output CSV file.

        Args:
            protocol: Protocol name ('modbus', 'smb2', 'dhcp', 'dns')

        Returns:
            Tuple of (messages, ground_truth)
            - messages: List of raw protocol messages (bytes)
            - ground_truth: List of field boundary lists
        """
        protocol = protocol.lower()

        # Map protocol names to DynPRE output directories
        protocol_map = {
            'modbus': 'out-modbus/in-modbus-pcaps.ground_truth.csv',
            'smb2': 'out-smb2/in-smb2-pcaps.ground_truth.csv',
            # DHCP and DNS may not have DynPRE outputs yet
        }

        if protocol not in protocol_map:
            raise ValueError(f"No DynPRE ground truth available for protocol: {protocol}")

        csv_file = self.output_dir / protocol_map[protocol]

        if not csv_file.exists():
            raise FileNotFoundError(f"DynPRE ground truth file not found: {csv_file}")

        logging.info(f"Loading DynPRE ground truth from {csv_file}")

        messages = []
        ground_truth = []

        with open(csv_file, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)

            for row in reader:
                # Parse hexstream
                hexstream = row['Hexstream']
                message = bytes.fromhex(hexstream)
                messages.append(message)

                # Parse split indexes
                # Format: "[0, 2, 4, 6, 7, 8, 10, 12]"
                split_indexes_str = row['Split Indexes']
                split_indexes_str = split_indexes_str.strip('[]')
                split_indexes = [int(x.strip()) for x in split_indexes_str.split(',')]
                ground_truth.append(split_indexes)

        logging.info(f"Loaded {len(messages)} {protocol.upper()} messages with DynPRE ground truth")

        return messages, ground_truth

    def get_available_protocols(self) -> List[str]:
        """Get list of protocols with DynPRE ground truth available."""
        protocols = []

        protocol_files = {
            'modbus': 'out-modbus/in-modbus-pcaps.ground_truth.csv',
            'smb2': 'out-smb2/in-smb2-pcaps.ground_truth.csv',
        }

        for protocol, filepath in protocol_files.items():
            if (self.output_dir / filepath).exists():
                protocols.append(protocol)

        return protocols


def test_dynpre_loader():
    """Test the DynPRE ground truth loader."""
    loader = DynPREGroundTruthLoader(dynpre_output_dir='../../DynPRE/examples')

    protocols = loader.get_available_protocols()
    print(f"Available protocols with DynPRE ground truth: {protocols}")

    for protocol in protocols:
        print(f"\nTesting {protocol.upper()}:")
        messages, ground_truth = loader.load_ground_truth(protocol)
        print(f"  Loaded {len(messages)} messages")

        if messages:
            print(f"  First message length: {len(messages[0])} bytes")
            print(f"  First message hex: {messages[0].hex()}")
            print(f"  First message boundaries: {ground_truth[0]}")
            print(f"  Number of fields: {len(ground_truth[0]) - 1}")


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    test_dynpre_loader()
